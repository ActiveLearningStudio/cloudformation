AWSTemplateFormatVersion: '2010-09-09'
Description: 'EKS Deployment via EC2 Instance'
Parameters:
  PublicSubnetId:
    Type: String
    Description: ID of Public Subnet
  SSHKeyPair:
    Description: Ec2 Keypair Name
    Type: AWS::EC2::KeyPair::KeyName
  VpcId:
    Type: String
  VpcCidrBlock:
    Type: String
    Description: CIDR Block for VPC
  ClusterName: 
    Type: String
    Description: Name of your managed EKS Cluster
  AmiId:
    Type: AWS::SSM::Parameter::Value<String>
    Description: ParameterStore name of the Parameter containing Ubuntu AMI
    Default: /aws/service/canonical/ubuntu/server/20.04/stable/current/amd64/hvm/ebs-gp2/ami-id
  AwsAccessKeyId:
    Type: String
    Description: AWS Access Key ID
    NoEcho: "true"
  AwsSecretAccessKey:
    Type: String
    Description: AWS Secret Access Key
    NoEcho: "true"
  HostedZoneId:
    Type: String
    Description: Route53 hosted zone id
  DomainName:
    Type: String
    Description: Domain name without http/https (www.example.com or *.example.com)
  AdminDomainName:
    Type: String
    Description: Domain name without http/https (for admin server). Should be same subdomain as DomainName.
  # ValidationDomainName:
  #   Type: String
  #   Description: Fully Qualified domain Name (www.example.com)
  S3BucketURL:
    Type: String
    Description: S3 Bucket URL
  AcmCertArn:
    Type: String
    Description: Arn
  # DatabaseInstanceType: 
  #   AllowedValues: 
  #     - db.t2.micro
  #     - db.t2.small
  #     - db.r3.large
  #     - db.r3.xlarge
  #     - db.r3.2xlarge
  #     - db.r3.4xlarge
  #     - db.r3.8xlarge
  #   Default: db.t2.micro
  #   Description: "The instance type to use for the database."
  #   Type: String
  # DatabasePassword: 
  #   Description: "The database admin account password."
  #   MaxLength: "41"
  #   MinLength: "8"
  #   NoEcho: "true"
  #   Type: String
  # DatabaseUsername: 
  #   AllowedPattern: "[a-zA-Z0-9]+"
  #   ConstraintDescription: "must contain only alphanumeric characters."
  #   Default: awsmaster
  #   Description: "The database admin account user name."
  #   MaxLength: "16"
  #   MinLength: "1"
  #   Type: String
  # MultiAZ: 
  #   AllowedValues: 
  #     - true
  #     - false
  #   Description: "Multi AZ setup for database"
  #   Type: String
  # PGVersion: 
  #   Default: "9.6"
  #   Description: "PostgreSQL Version"
  #   Type: String
  # PrivateSubnets:
  #   Type: String
Resources:
  Ec2Instance:
    DependsOn:
      - EksEfsFileSystem
      - Ec2SecurityGroup
      # - AcmCertArn
    Type: AWS::EC2::Instance
    Properties: 
      ImageId: !Ref AmiId
      InstanceType: t2.micro
      KeyName: !Ref SSHKeyPair
      SecurityGroupIds: 
        - !Ref Ec2SecurityGroup
      SubnetId: !Ref PublicSubnetId
      UserData: 
        Fn::Base64: 
          !Sub |
            #!/bin/bash
            apt upgrade -y && apt update -y
            apt install awscli nfs-common unzip -y
            snap install kubectl --classic

            # set up AWS creds
            aws configure set aws_access_key_id ${AwsAccessKeyId} --profile default 
            aws configure set aws_secret_access_key ${AwsSecretAccessKey} --profile default
            aws eks update-kubeconfig --name ${ClusterName} --region ${AWS::Region}

            # Pull down code
            git clone -b develop https://github.com/ActiveLearningStudio/curriki-eks.git
            cp /curriki-eks/envs/.env.client.example /curriki-eks/envs/.env.local
            cp /curriki-eks/envs/.env.api.example /curriki-eks/envs/.env

            # Create k8s secrets
            sudo kubectl create secret generic currikidev-api-secret --from-file=/curriki-eks/envs/.env
            sudo kubectl create secret generic currikidev-client-secret --from-file=/curriki-eks/envs/.env.local
            sudo kubectl create secret generic currikidev-admin-secret --from-file=/curriki-eks/envs/.env.admin
            
            # Deploy Client
            sudo kubectl apply -f /curriki-eks/yamls/client.yaml

            # Download istioctl
            curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.7.3 TARGET_ARCH=x86_64 sh -
            
            # Set up istio yaml file to use our ACM certificate.
            escapedarn=$(echo "${AcmCertArn}" | sed 's%/%\\/%g')
            sed "s/substitute-me-acm-cert-substitute-me/$escapedarn/g" /curriki-eks/yamls/istio-install.yaml  > /curriki-eks/yamls/istio-install.yaml.new
            mv /curriki-eks/yamls/istio-install.yaml.new /curriki-eks/yamls/istio-install.yaml
            
            # Install istio
            sudo /istio-1.7.3/bin/istioctl install --set profile=default -f /curriki-eks/yamls/istio-install.yaml
            sudo kubectl label namespace default istio-injection=disabled  # we don't need istio injection.

            # Configure istio ingress to route to api + admin.
            sudo kubectl apply -f /curriki-eks/yamls/istio.yaml

            # Install kubernetes EFS driver
            kubectl apply -k "github.com/kubernetes-sigs/aws-efs-csi-driver/deploy/kubernetes/overlays/stable/?ref=master"

            # Create EFS mount targets for all subnets in the VPC
            /curriki-eks/scripts/create_efs_mount_targets.sh $ClusterName $Ec2SecurityGroup $EksEfsFileSystem

            # Substitute the EFS mount target into the API and Admin Yaml files
            # Note: it's fine to use the same mount target but for different volumes.
            sed 's/substitute-me-efs-substitute-me/${EksEfsFileSystem}/g' /curriki-eks/yamls/api.yaml > /curriki-eks/yamls/api.yaml.new
            mv /curriki-eks/yamls/api.yaml.new /curriki-eks/yamls/api.yaml
            sed 's/substitute-me-efs-substitute-me/${EksEfsFileSystem}/g' /curriki-eks/yamls/admin.yaml > /curriki-eks/yamls/admin.yaml.new
            mv /curriki-eks/yamls/admin.yaml.new /curriki-eks/yamls/admin.yaml

            # Substitute the hostnames into istio.yaml
            sed 's/replace-me-curriki-host/${DomainName}/g' /curriki-eks/yamls/istio.yaml > /curriki-eks/yamls/istio.yaml.new
            mv /curriki-eks/yamls/istio.yaml.new /curriki-eks/yamls/istio.yaml
            sed 's/replace-me-curriki-host/${AdminDomainName}/g' /curriki-eks/yamls/istio.yaml > /curriki-eks/yamls/istio.yaml.new
            mv /curriki-eks/yamls/istio.yaml.new /curriki-eks/yamls/istio.yaml

            # Deploy the Admin and API
            sudo kubectl apply -f /curriki-eks/yamls/admin.yaml
            sudo kubectl apply -f /curriki-eks/yamls/api.yaml

            # TODO: wait 5 min and then figure out how to check that pods came up properly.

        #sudo kubectl apply -f /curriki-eks/yamls/api.yaml
        #sed 's/substitute-me-efs-substitute-me/${EksEfsFileSystem}/g' /curriki-eks/yamls/api.yaml
        #mkdir ~/efs-mount
        #wget ${S3BucketURL}/storage/storage.zip
        #unzip storage.zip -d ~/efs-mount
        #sudo mount -t nfs4 -o nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport ${EksEfsFileSystem}.efs.${AWS::Region}.amazonaws.com:/ ~/efs-mount
        # sudo /istio-1.7.3/bin/istioctl install --set profile=demo
  Ec2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH Access via Port 22.
      VpcId: !Ref VpcId
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: '8080'
        ToPort: '8080'
        CidrIp: 0.0.0.0/0
      - IpProtocol: tcp
        FromPort: '22'
        ToPort: '22'
        CidrIp: 0.0.0.0/0
      - IpProtocol: tcp
        FromPort: '2049'
        ToPort: '2049'
        CidrIp: 0.0.0.0/0
      Tags:
      - Key: Name
        Value: !Sub ${AWS::StackName}-EksDeploymentSG
  
  # DatabaseSecurityGroup: 
  #   Type: "AWS::EC2::SecurityGroup"
  #   Properties: 
  #     GroupDescription: "Postgres DB Security Group"
  #     SecurityGroupIngress: 
  #       - 
  #         CidrIp: !Ref VpcCidrBlock
  #         FromPort: "5432"
  #         IpProtocol: tcp
  #         ToPort: "5432"
  #     Tags: 
  #       - 
  #         Key: Name
  #         Value: 
  #           ? "Fn::Join"
  #           : 
  #             - "-"
  #             - 
  #               - 
  #                 Ref: ClusterName
  #               - rds
  #     VpcId: !Ref VpcId
    
  # DatabaseSubnetGroup: 
  #   Type: "AWS::RDS::DBSubnetGroup"
  #   Properties: 
  #     DBSubnetGroupDescription: "DB Subnet Group"
  #     SubnetIds: 
  #       Fn::Split:
  #       - ","
  #       - !Ref PrivateSubnets
  #     Tags: 
  #       - 
  #         Key: Name
  #         Value: "rds-db-SubnetGroup"
    
  # RDSDBInstance: 
  #   Type: "AWS::RDS::DBInstance"
  #   DeletionPolicy: Snapshot
  #   Properties: 
  #     AllocatedStorage: "20"
  #     AllowMajorVersionUpgrade: "false"
  #     AutoMinorVersionUpgrade: "true"
  #     BackupRetentionPeriod: "7"
  #     CopyTagsToSnapshot: true
  #     DBInstanceClass: 
  #       Ref: DatabaseInstanceType
  #     DBInstanceIdentifier: !Sub "${ClusterName}-rds"
  #     DBName: !Sub "${ClusterName}_rds"
  #     DBSubnetGroupName:
  #       Ref: DatabaseSubnetGroup
  #     Engine: postgres
  #     EngineVersion: 
  #       Ref: PGVersion
  #     MasterUserPassword: 
  #       Ref: DatabasePassword
  #     MasterUsername: 
  #       Ref: DatabaseUsername
  #     MultiAZ: 
  #       Ref: MultiAZ
  #     PreferredBackupWindow: "05:00-05:30"
  #     PreferredMaintenanceWindow: "mon:06:00-mon:06:30"
  #     PubliclyAccessible: false
  #     StorageType: gp2
  #     VPCSecurityGroups:
  #       - Ref: DatabaseSecurityGroup

  EksEfsFileSystem:
    Type: AWS::EFS::FileSystem
    Properties: 
      BackupPolicy: 
        Status: ENABLED
      Encrypted: true
      FileSystemTags: 
        - Key: Name
          Value: EksEfsFileSystem
      LifecyclePolicies: 
        - TransitionToIA: AFTER_30_DAYS
  # AcmCertArn:
  #   Type: AWS::CertificateManager::Certificate
  #   Properties:
  #     DomainName: !Ref DomainName
  #     DomainValidationOptions:
  #       - DomainName: !Ref ValidationDomainName
  #         HostedZoneId: !Ref HostedZoneId
  #     ValidationMethod: DNS

  # # I've commented this out because I'm creating the EFS Mount Targets in a bash script for now.
  # EksEfsTarget:
  #   Type: AWS::EFS::MountTarget
  #   Properties: 
  #     FileSystemId: !Ref EksEfsFileSystem
  #     SecurityGroups: 
  #       - !Ref Ec2SecurityGroup
  #     SubnetId: !Ref PublicSubnetId
